[
  {
    "objectID": "domoaccount.html",
    "href": "domoaccount.html",
    "title": "DomoAccount",
    "section": "",
    "text": "source\n\n\n\n get_accounts (full_auth:nbdev_domo.DomoAuth.DomoAuth, debug:bool=False,\n               session:Optional[aiohttp.client.ClientSession]=None)\n\nretrieves a list of all accounts this auth has read access to.\n\n\n\nimport os\nimport json\nimport pandas as pd\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n\n    accounts_res = await get_accounts(full_auth=domo_auth)\n\n    account_ls = accounts_res.response\n    print(pd.DataFrame(account_ls[0:4]))\n\nexcept Exception as e:\n    print(e)\n\n'DOJO_CREDS'\n\n\n\nsource\n\n\n\n\n\n get_account_from_id (account_id:int,\n                      full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                      debug:bool=False,\n                      session:Optional[aiohttp.client.ClientSession]=None)\n\nretrieves metadata about an account, does not retrieve configuration settings\n\n\n\nimport os\nimport json\nimport pandas as pd\nfrom fastcore.test import test_eq\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n\n    account_res = await get_account_from_id(full_auth=domo_auth, account_id=ACCOUNT_ID)\n\n    domo_account = account_res.response\n    test_eq(type(domo_account), dict)\n\n    pd.DataFrame([domo_account])\n\nexcept Exception as e:\n    print(e)\n\n'DOJO_CREDS'\n\n\n\nsource\n\n\n\n\n\n get_account_config (account_id:int, data_provider_type:str,\n                     full_auth:nbdev_domo.DomoAuth.DomoAuth,\n                     debug:bool=False,\n                     session:Optional[aiohttp.client.ClientSession]=None)\n\nretrieves account configuration information, does not include metadata\n\n\n\nimport os\nimport json\nimport pandas as pd\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n\n    res = await get_account_config(\n        full_auth=domo_auth,\n        account_id=ACCOUNT_ID,\n        data_provider_type=ACCOUNT_DATA_PROVIDER_TYPE,\n    )\n\n    account_config = res.response\n    test_eq(type(account_config), dict)\n\n    pd.DataFrame([account_config])\n\nexcept Exception as e :\n    print(e)\n\n'DOJO_CREDS'\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n update_account_config (account_id:int, config_body:dict,\n                        data_provider_type:str,\n                        full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                        debug:bool=False, session:Optional[aiohttp.client.\n                        ClientSession]=None)\n\nupdates account configuration. does not alter metadata\n\nsource\n\n\n\n\n update_account_name (account_id:int, account_name:str,\n                      full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                      debug:bool=False,\n                      session:Optional[aiohttp.client.ClientSession]=None)\n\nupdate an accountâ€™s display name\n\n\n\n\nimport os\nimport json\nimport pandas as pd\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n    \n    await update_account_name(\n        full_auth=domo_auth,\n        account_id=ACCOUNT_ID,\n        account_name=\"test_update_function\",\n        debug=False,\n    )\nexcept Exception as e:\n    print(e)\n\n'DOJO_CREDS'\n\n\n\n\n\nTo create a new config_body use the DomoAccount_Config class as the basis for a new class, then add it to the AccountConfig enum.\n\nsource\n\n\n\n\n create_account_route (config_body:dict,\n                       full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                       debug:bool=False, session:Optional[aiohttp.client.C\n                       lientSession]=None)\n\ncreate a new Domo Account object\n\n\n\n\nsource\n\n\n\n\n delete_account_route (account_id:str,\n                       full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                       debug:bool=False, session:Optional[aiohttp.client.C\n                       lientSession]=None)"
  },
  {
    "objectID": "domoaccount.html#domo-account-configuration-types",
    "href": "domoaccount.html#domo-account-configuration-types",
    "title": "DomoAccount",
    "section": "Domo Account Configuration Types",
    "text": "Domo Account Configuration Types\nHelper classes to handle account configuration operations.\n\nsource\n\nDomoAccount_Config\n\n DomoAccount_Config ()\n\nAbstract method for defining Domo Account Configuration bodies.\n\nEach implementation should have properties unique to the account configuration.\nEach implementation should have an internal classmethod for converting an API response to an object\nEach implementation should have an internal method for converting the class object into a json object.\n\n\n# list of required methods\n[\n    prop\n    for prop in dir(DomoAccount_Config)\n    if not prop.startswith(\"__\") and prop != \"_abc_impl\"\n]\n\n['_from_json', 'to_json']\n\n\n\nsource\n\n\nDomoAccount_Config_DomoGovernance\n\n DomoAccount_Config_DomoGovernance (api_key:str, customer:str,\n                                    data_provider_type:str='domo-\n                                    governance')\n\n\nsource\n\n\nDomoAccount_Config_AbstractCredential\n\n DomoAccount_Config_AbstractCredential (credentials:str,\n                                        data_provider_type:str='abstract-\n                                        credential-store')\n\n\nsource\n\n\nDomoAccount_Config_Athena_HighBandwidthConnector\n\n DomoAccount_Config_Athena_HighBandwidthConnector (aws_access_key:str,\n                                                   aws_secret_key:str,\n                                                   s3_staging_dir:str,\n                                                   region:str='us-west-2')"
  },
  {
    "objectID": "domoaccount.html#accountconfig-enum",
    "href": "domoaccount.html#accountconfig-enum",
    "title": "DomoAccount",
    "section": "AccountConfig Enum",
    "text": "AccountConfig Enum\nAccountConfig enum matches dataProviderType with a Config class.\n\nclass AccountConfig(Enum):\n    \"\"\"enum to match account types with config classes\"\"\"\n\n    amazon_athena_high_bandwidth = DomoAccount_Config_Athena_HighBandwidthConnector\n    abstract_credential_store = DomoAccount_Config_AbstractCredential\n    domo_governance = DomoAccount_Config_DomoGovernance\n\n\nsource\n\nAccountConfig\n\n AccountConfig (value, names=None, module=None, qualname=None, type=None,\n                start=1)\n\nenum to match account types with config classes"
  },
  {
    "objectID": "domoaccount.html#main---domoaccount",
    "href": "domoaccount.html#main---domoaccount",
    "title": "DomoAccount",
    "section": "MAIN - DomoAccount",
    "text": "MAIN - DomoAccount\n\nsource\n\nDomoAccount\n\n DomoAccount (display_name:str, data_provider_type:str, id:int=None,\n              created_dt:Optional[datetime.datetime]=None,\n              modified_dt:Optional[datetime.datetime]=None,\n              full_auth:nbdev_domo.DomoAuth.DomoFullAuth=None,\n              config:Optional[__main__.AccountConfig]=None,\n              logger:Optional[nbdev_domo.Logger.Logger]=None)\n\nclass for interacting with Domo Account entities\n\nsource\n\n\nDeleteAccountError\n\n DeleteAccountError (status:Optional[int]=None, message='failed to delete\n                     account', domo_instance:Optional[str]=None)\n\nreturn if fail to delete Domo Account\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\nfailed to delete account\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone\n\n\n\n\n\nsource\n\n\nUpdateAccountConfigError\n\n UpdateAccountConfigError (status:Optional[int]=None, message='failed to\n                           update account config',\n                           domo_instance:Optional[str]=None)\n\nreturn if DomoAccount does not have a valid config attribute\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\nfailed to update account config\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone\n\n\n\n\n\nsource\n\n\nInvalidAccountConfigError\n\n InvalidAccountConfigError (status:Optional[int]=None, message='invalid\n                            account config',\n                            domo_instance:Optional[str]=None)\n\nreturn if DomoAccount does not have a valid config attribute\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid account config\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone\n\n\n\n\n\nsource\n\n\nInvalidAccountError\n\n InvalidAccountError (status:Optional[int]=None, message='invalid\n                      account', domo_instance:Optional[str]=None)\n\nreturn invalid account id sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid account\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone\n\n\n\n\n\nsource\n\n\nDomoAccount.get_from_id\n\n DomoAccount.get_from_id (full_auth:nbdev_domo.DomoAuth.DomoAuth,\n                          account_id:int,\n                          session:aiohttp.client.ClientSession=None,\n                          logger:Optional[nbdev_domo.Logger.Logger]=None,\n                          debug:bool=False)\n\nRetrieves account metadata and attempts to retrieve config information.\nTo retrieve config data, a matching DomoAccount_Config class and AccountConfig enum entry must exist. * The match is an approximate match based on â€˜startswithâ€™\n\nsample implementation of DomoAccount.get_from_id\n\nimport os\nimport json\nimport pandas as pd\nfrom pprint import pprint\n\nimport nbdev_domo.Logger as lg\n\n\n## example of failed account retrieval with a logger\nlogger = lg.Logger(app_name=\"test_domo_account\")\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n\n    domo_account = await DomoAccount.get_from_id(\n        full_auth=domo_auth, account_id=73, logger=logger\n    )\n\nexcept Exception as e:\n    print(e)\n\nfinally:\n    pprint(logger.logs)\n\n'DOJO_CREDS'\n[]\n\n\n\nimport os\nimport json\nimport pandas as pd\n\n# example of successful account retrieval with a logger\nlogger = lg.Logger(app_name=\"test_domo_account_v2\")\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n    \n    domo_account = await DomoAccount.get_from_id(\n        full_auth=domo_auth, account_id=ACCOUNT_ID, logger=logger )\n    print(domo_account)\n\nexcept Exception as e:\n    print(e)\n\nfinally:\n    print(pd.DataFrame(logger.logs))\n\n'DOJO_CREDS'\nEmpty DataFrame\nColumns: []\nIndex: []\n\n\n\nsource\n\n\n\nDomoAccount.update_config\n\n DomoAccount.update_config\n                            (config_body:Optional[__main__.DomoAccount_Con\n                            fig]=None, full_auth:nbdev_domo.DomoAuth.DomoF\n                            ullAuth=None, debug:bool=False,\n                            session:aiohttp.client.ClientSession=None)\n\nupdate account configuration, does not update metadata\n\nsource\n\n\nDomoAccount.update_name\n\n DomoAccount.update_name (account_name:str=None,\n                          full_auth:nbdev_domo.DomoAuth.DomoFullAuth=None,\n                          debug:bool=False, session:Optional[aiohttp.clien\n                          t.ClientSession]=None)\n\nupdates account display name\n\nimport os\nimport json\nimport pandas as pd\n\ntry:\n    creds = json.loads(os.environ[\"DOJO_CREDS\"])\n\n    domo_auth = dmda.DomoFullAuth(\n        domo_username=creds.get(\"domo_username\", \"test@domo.com\"),\n        domo_password=creds.get(\"domo_password\", \"testpassword\"),\n        domo_instance=\"domo-dojo\",\n    )\n    \n    domo_account = await DomoAccount.get_from_id(full_auth=domo_auth, account_id=ACCOUNT_ID)\n\n    await domo_account.update_name(\n        account_name=\"test_rename_using_classmethod\", debug=False\n    )\n\n    pd.DataFrame(domo_account.logger.logs)\n    \nexcept Exception as e:\n    print(e)\n\n'DOJO_CREDS'\n\n\n\nsample implementation of update_name\n\nsource\n\n\n\nDomoAccount.delete_account\n\n DomoAccount.delete_account (account_id:int,\n                             full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                             debug:bool=False,\n                             session:aiohttp.client.ClientSession=None, lo\n                             gger:Optional[nbdev_domo.Logger.Logger]=None)\n\nclassmethod to delete an account\n\nsource\n\n\nDomoAccount.create_account\n\n DomoAccount.create_account (display_name:str,\n                             domoaccount_config:__main__.DomoAccount_Confi\n                             g,\n                             full_auth:nbdev_domo.DomoAuth.DomoFullAuth,\n                             debug:bool=False, session:Optional[aiohttp.cl\n                             ient.ClientSession]=None)\n\ncreate a new Domo Account object"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nbdev_domo",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "nbdev_domo",
    "section": "Install",
    "text": "Install\npip install nbdev_domo"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "nbdev_domo",
    "section": "How to use",
    "text": "How to use\nFill me in please! Donâ€™t forget code examples:\n\n1+1\n\n2\n\n\n\n# DomoFullAuth(domo_instance = 'test', domo_password = 'test', domo_username='test2@domo.com')"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utility Functions",
    "section": "",
    "text": "source\n\nDictDot\n\n DictDot (dictionary, **kwargs)\n\nconvenience class that converts dictionaries to objects with attributes that can be accessed with dot notation.\n\nsample implementation of DictDot\nIn this library, weâ€™ll requently use the DictDot to convert ResponseGetData response dictionaries into a class with attributes that can be accessed with dot notation to simulate dot notation in JavaScript scripting\n\nsample_dict = {\"id\" : '123', 'name': 'Juliette Rosenberg', 'type': 'mage'}\n\ndd = DictDot(sample_dict)\n\ndd.name\n\n'Juliette Rosenberg'\n\n\n\n\n\nDateTime Conversion functions\n\nsource\n\nconvert_datetime_to_epoch_millisecond\n\n convert_datetime_to_epoch_millisecond (datetime:datetime.datetime)\n\nconvert DateTime to Epoch time with Miliseconds\n\nsource\n\n\nconvert_epoch_millisecond_to_datetime\n\n convert_epoch_millisecond_to_datetime (epoch:int)\n\nconvert Epoch time with miliseconds to Date time\n\n\n\nText Conversion functions\n\nsource\n\nconvert_snake_to_pascal\n\n convert_snake_to_pascal (str)"
  },
  {
    "objectID": "domoauth.html",
    "href": "domoauth.html",
    "title": "DomoAuth",
    "section": "",
    "text": "The nbdev_domo library was designed to support object-oriented / class-based programming; however, all routes are stand-alone functions for users who prefer a functional programming approach\n\n\nIf SSO is enabled, users must have direct-sign-on (SSO KB) access to use this authentication method.\n\nsource\n\n\n\n get_full_auth (domo_instance:str, domo_username:str, domo_password:str,\n                session:Optional[aiohttp.client.ClientSession]=None)\n\nuses username and password authentication to retrieve a full_auth access token\n\n\n\n# load creds from env\nimport os\nimport json\n\ntry:\n    creds = json.loads(os.environ['DOMO_DOJO'])\nexcept:\n    creds = {}\n\ndomo_instance = creds.get('domo_instance') or \"domo-dojo\"\ndomo_username = creds.get('domo_username') or \"test12@domo.com\"\ndomo_password = creds.get('domo_password') or \"test1234\"\n\nres = await get_full_auth(domo_instance, domo_username, domo_password)\n\n# The 200 response confirms we were able to get a response from the credentials API,\ntest_eq(res.status, 200)\n\nres\n\nResponseGetData(status=200, response={'success': False, 'reason': 'INVALID_CREDENTIALS'}, is_success=True)\n\n\n\ndomo_instance = \"test\"\nres = await get_full_auth(domo_instance, domo_username, domo_password)\n\n# the 403 response confirms that there is no domo instance 'test.domo.com'\ntest_eq(res.status, 403)\nres\n\nResponseGetData(status=403, response='Forbidden', is_success=False)\n\n\n\n\n\n\n\nThis access_token based authentication assumes the user has been provided a valid access token from Domo > Admin > Authentication > Access Token so authentication routes are actually not required.\nPer the Domo JavaCLI implementation, users can test the validity of the access_token agains the â€˜meâ€™ API\n!! Note about the Me API !! It appears that access_token authentication will always authenticate against the â€˜correctâ€™ domo_instance regardless of the parameter provided. Ths appears to be a bug in the domo_api\n\nsource\n\n\n\n test_access_token (domo_access_token:str, domo_instance:str,\n                    session:Optional[aiohttp.client.ClientSession]=None)\n\nwill attempt to validate against the â€˜meâ€™ API. This is the same authentication test the Domo Java CLI uses.\n\n\n\n# load creds from env\nimport os\n\ntry:\n    creds = os.environ['DOMO_DOJO_ACCESS_TOKEN']\nexcept:\n    creds = None\n\ndomo_instance = \"test\"\ndomo_access_token = creds or \"test123\"\n\nawait test_access_token(\n    domo_instance=domo_instance, domo_access_token=domo_access_token\n)\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)\n\n\n\n\n\n\n\n\nsource\n\n\n\n get_developer_auth (domo_client_id:str, domo_client_secret:str,\n                     session:Optional[aiohttp.client.ClientSession]=None)\n\nonly use for authenticating against apis documented under developer.domo.com\n\n\nThe 401 response is expected because we are using invalid credentials\n\ndomo_client_id = \"test_id\"\ndomo_client_secret = \"test_secret\"\n\nawait get_developer_auth(domo_client_id, domo_client_secret)\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)"
  },
  {
    "objectID": "domoauth.html#domoauth-error-classes",
    "href": "domoauth.html#domoauth-error-classes",
    "title": "DomoAuth",
    "section": "DomoAuth Error Classes",
    "text": "DomoAuth Error Classes\nUsed to raise exceptions during authentication process.\n\nsource\n\nInvalidInstanceError\n\n InvalidInstanceError (status:Optional[int]=None, message='invalid\n                       instance', domo_instance:Optional[str]=None)\n\nreturn if invalid domo_instance sent to API\n\nsource\n\n\nInvalidCredentialsError\n\n InvalidCredentialsError (status:Optional[int]=None, message='invalid\n                          credentials', domo_instance:Optional[str]=None)\n\nreturn invalid credentials sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\ntyping.Optional[int]\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid credentials\n\n\n\ndomo_instance\ntyping.Optional[str]\nNone"
  },
  {
    "objectID": "domoauth.html#domofullauth",
    "href": "domoauth.html#domofullauth",
    "title": "DomoAuth",
    "section": "DomoFullAuth",
    "text": "DomoFullAuth\n\nsource\n\nDomoFullAuth\n\n DomoFullAuth (domo_instance:str, domo_username:str, domo_password:str,\n               token:Optional[str]=None, token_name:Optional[str]=None,\n               user_id:Optional[str]=None, auth_header:dict=<factory>,\n               url_manual_login:Optional[str]=None,\n               logger:Optional[nbdev_domo.Logger.Logger]=None)\n\nuse for full authentication token\n\nsample implementations of DomoFullAuth\n\nimport nbdev_domo.Logger as lg\n\ndomo_instance = \"domo-dojo\"\ndomo_username = \"test12@domo.com\"\ndomo_password = \"test1234\"\n\nlogger = lg.Logger(app_name = 'test_auth', domo_instance= domo_instance)\n\ntry:\n    full_auth = DomoFullAuth(domo_instance, domo_username, domo_password, logger = logger)\n    res = await full_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nlogger.logs\n\nStatus 200 - invalid credentials at domo-dojo\n\n\n[{'date_time': datetime.datetime(2023, 1, 12, 1, 50, 47, 980411),\n  'application': 'test_auth',\n  'log_type': 'Error',\n  'log_message': 'invalid credentials',\n  'breadcrumb': '',\n  'domo_instance': 'domo-dojo',\n  'entity_id': None,\n  'function_name': 'get_auth_token',\n  'file_name': '<ipython-input-1-27054c38d1b5>',\n  'function_trail': '<module> -> get_auth_token'}]\n\n\n\ndomo_instance = \"test\"\n\ntry:\n    full_auth = DomoFullAuth(domo_instance, domo_username, domo_password)\n    await full_auth.get_auth_token()\n    \nexcept InvalidInstanceError as e:\n    print(e)\n\nfull_auth.logger.logs\n\nStatus 403 - INVALID INSTANCE at test\n\n\n[{'date_time': datetime.datetime(2023, 1, 4, 22, 53, 6, 899179),\n  'application': 'default_domo_full_auth',\n  'log_type': 'Error',\n  'log_message': 'invalid instance',\n  'breadcrumb': '',\n  'domo_instance': 'test',\n  'entity_id': None,\n  'function_name': 'get_auth_token',\n  'file_name': '/tmp/ipykernel_6708/4043354304.py',\n  'function_trail': '<module> -> get_auth_token'}]"
  },
  {
    "objectID": "domoauth.html#domotokenauth",
    "href": "domoauth.html#domotokenauth",
    "title": "DomoAuth",
    "section": "DomoTokenAuth",
    "text": "DomoTokenAuth\n\nsource\n\nDomoTokenAuth\n\n DomoTokenAuth (domo_instance:str, domo_access_token:str,\n                token:Optional[str]=None, token_name:Optional[str]=None,\n                user_id:Optional[str]=None, auth_header:dict=<factory>,\n                url_manual_login:Optional[str]=None,\n                logger:Optional[nbdev_domo.Logger.Logger]=None)\n\nuse for access_token authentication. Tokens are generated in domo > admin > access token Necessary in cases where direct sign on is not permitted\n\nSample implementation of DomoTokenAuth\n\ndomo_instance = \"test\"\ndomo_access_token = \"test_access_token\"\n\ntry:\n    domo_auth = DomoTokenAuth(domo_instance, domo_access_token)\n    token = await domo_auth.get_auth_token()\n    print(domo_auth.token)\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\ndomo_auth.logger.logs\n\nStatus 401 - Unauthorized at test\n\n\n[{'date_time': datetime.datetime(2023, 1, 4, 22, 53, 7, 660910),\n  'application': 'default_domo_token_auth',\n  'log_type': 'Error',\n  'log_message': 'Unauthorized',\n  'breadcrumb': '',\n  'domo_instance': 'test',\n  'entity_id': None,\n  'function_name': 'get_auth_token',\n  'file_name': '/tmp/ipykernel_6708/804034571.py',\n  'function_trail': '<module> -> get_auth_token'}]"
  },
  {
    "objectID": "domoauth.html#domodeveloperauth",
    "href": "domoauth.html#domodeveloperauth",
    "title": "DomoAuth",
    "section": "DomoDeveloperAuth",
    "text": "DomoDeveloperAuth\n\nsource\n\nDomoDeveloperAuth\n\n DomoDeveloperAuth (domo_client_id:str, domo_client_secret:str,\n                    logger:Optional[nbdev_domo.Logger.Logger]=None)\n\nuse for full authentication token\n\nSample implementations of DomoDeveloperAuth\n\ndomo_client_id = \"test_client\"\ndomo_client_secret = \"test_secret\"\n\ntry:\n    domo_auth = DomoDeveloperAuth(domo_client_id = domo_client_id, domo_client_secret = domo_client_secret)\n    await domo_auth.get_auth_token()\nexcept InvalidCredentialsError as e:\n    print(e)\n\ndomo_auth.logger.logs\n\nStatus 401 - Unauthorized\n\n\n[{'date_time': datetime.datetime(2023, 1, 4, 22, 53, 8, 231464),\n  'application': 'default_domo_developer_auth',\n  'log_type': 'Error',\n  'log_message': 'Unauthorized',\n  'breadcrumb': '',\n  'domo_instance': '',\n  'entity_id': None,\n  'function_name': 'get_auth_token',\n  'file_name': '/tmp/ipykernel_6708/2043329489.py',\n  'function_trail': '<module> -> get_auth_token'}]"
  },
  {
    "objectID": "responsegetdata.html",
    "href": "responsegetdata.html",
    "title": "ResponseGetData",
    "section": "",
    "text": "All API routes should return an instance of ResponseGetData.\n\nsource\n\nResponseGetData\n\n ResponseGetData (status:int, response:Union[list,dict,str],\n                  is_success:bool, auth_header:Optional[dict]=None)\n\npreferred response class for all API routes\n\nSample Implementation of ResponseGetData\n\nrgd = ResponseGetData(status=200, response=\"test\", is_success=True)\nrgd\n\nResponseGetData(status=200, response='test', is_success=True, auth_header=None)\n\n\n\n\n\nGenerate ResponseGetData with classmethods\nUsers can generate an instance of the ResponseGetData class from two private classmethods (see below).\nThis class currently supports implementations of two API request libraries, requests.request (synchronous) and aiohttp.ClientRequest (asynchronous).\n\nsource\n\nResponseGetData._from_requests_response\n\n ResponseGetData._from_requests_response (res:requests.models.Response,\n                                          auth_header:Optional[dict]=None)\n\nreturns ResponseGetData\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nres\nResponse\n\nrequests response object\n\n\nauth_header\ntyping.Optional[dict]\nNone\nauth header used to authenticate request\n\n\nReturns\nResponseGetData\n\n\n\n\n\n\nsample implementation of _from_requests_response\n\ntest_url = 'http://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita'\n\nres = requests.request(method='GET', url=test_url)\n\ntest_res = ResponseGetData._from_requests_response(res, auth_header = {'x-domo-authentication': 'test123'})\ntest_res.__dict__.keys()\n\ndict_keys(['status', 'response', 'is_success', 'auth_header'])\n\n\n\nsource\n\n\n\nResponseGetData._from_aiohttp_response\n\n ResponseGetData._from_aiohttp_response\n                                         (res:aiohttp.client_reqrep.Client\n                                         Response,\n                                         auth_header:Optional[dict]=None)\n\nasync method returns ResponseGetData\n\nsample implementation of _from_aiohttp_response.\nNotice the use of async / await\n\ntest_url = 'http://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita'\n\ntimeout = aiohttp.ClientTimeout(total=10)\nsession = aiohttp.ClientSession(timeout=timeout)\n\ntry:\n    res = await session.get(url=test_url)\n\n    test_res = await ResponseGetData._from_aiohttp_response(res)\n    print(test_res.__dict__.keys())\nexcept TimeoutError as e:\n    # sometimes aiohttp errors out for unexpected reasons.\n    print(e)\n\nfinally:\n    await session.close()\n\ndict_keys(['status', 'response', 'is_success', 'auth_header'])"
  },
  {
    "objectID": "logger.html",
    "href": "logger.html",
    "title": "Logger",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "logger.html#logger-traceback-methods",
    "href": "logger.html#logger-traceback-methods",
    "title": "Logger",
    "section": "Logger traceback methods",
    "text": "Logger traceback methods\nPrivate methods for adding traceback details to logs\n\nsource\n\nLogger._get_traceback\n\n Logger._get_traceback (root_module:str='<module>', num_stacks_to_drop=0)\n\nmethod that retrieves traceback\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nroot_module\nstr\n\n\n\n\nnum_stacks_to_drop\nint\n0\ndrop entries from the top of stack to exclude the functions that retrieve the traceback\n\n\nReturns\n[<class â€˜traceback.FrameSummaryâ€™>]\n\n\n\n\n\n\nsource\n\n\nTracebackDetails\n\n TracebackDetails (function_name:str, file_name:str, function_trail:str)\n\nresult of _get_traceback_details function\n\nsource\n\n\nLogger._get_traceback_details\n\n Logger._get_traceback_details\n                                (traceback_list:[<class'traceback.FrameSum\n                                mary'>])\n\nreturns TracebackDetails, for the entry at the top of the stack\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntraceback_list\n[<class â€˜traceback.FrameSummaryâ€™>]\n\n\n\nReturns\nTracebackDetails\ndescriptive summary from the top of the traceback\n\n\n\n\n\nsample implementations of stack tracing methods\n\nimport pandas as pd\n\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_trace():\n    return logger._get_traceback(num_stacks_to_drop=1)\n\n\n# print traceback for the test_trace function\n# notice with num_stacks_to_drop = 1 we exclude the _get_traceback function from the traceback\ntb = test_trace()\nprint({\"traceback function\": [line[2] for line in tb]})\n\n\ndef test_get_details():\n    tb = logger._get_traceback(num_stacks_to_drop=1)\n    return logger._get_traceback_details(tb)\n\n\n# print traceback details for test_get_details function\ntest_get_details().__dict__\n\n{'traceback function': ['<module>', 'test_trace']}\n\n\n{'function_name': 'test_get_details',\n 'file_name': '<ipython-input-1-67d667b8d98b>',\n 'function_trail': '<module> -> test_get_details'}\n\n\n\n# assert that the result of test_trace is of type FrameSummary\ntest_eq(type(tb[0]), traceback.FrameSummary)"
  },
  {
    "objectID": "logger.html#logger-logging-methods",
    "href": "logger.html#logger-logging-methods",
    "title": "Logger",
    "section": "Logger logging methods",
    "text": "Logger logging methods\n\nsource\n\nLogger.log_warning\n\n Logger.log_warning (message, entity_id:Optional[str]=None,\n                     domo_instance:Optional[str]=None, debug=False,\n                     num_stacks_to_drop=3)\n\nlog a warning message\n\nsource\n\n\nLogger.log_error\n\n Logger.log_error (message, entity_id:Optional[str]=None,\n                   domo_instance:Optional[str]=None, debug=False,\n                   num_stacks_to_drop=3)\n\nlog an error message\n\nsource\n\n\nLogger.log_info\n\n Logger.log_info (message, entity_id:Optional[str]=None,\n                  domo_instance:Optional[str]=None, debug=False,\n                  num_stacks_to_drop=3)\n\nlog an informational message\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_log():\n    return logger.log_info(\"test the error returns type Info\", debug=False)\n\n\ntest_log()\n\n{'date_time': datetime.datetime(2023, 1, 4, 17, 41, 30, 324941),\n 'application': 'test',\n 'log_type': 'Info',\n 'log_message': 'test the error returns type Info',\n 'breadcrumb': '',\n 'domo_instance': None,\n 'entity_id': None,\n 'function_name': 'test_log',\n 'file_name': '/tmp/ipykernel_11201/2671993135.py',\n 'function_trail': '<module> -> test_log'}"
  },
  {
    "objectID": "logger.html#outputting-logs",
    "href": "logger.html#outputting-logs",
    "title": "Logger",
    "section": "Outputting Logs",
    "text": "Outputting Logs\nDuring Logger instantiation, users can pass a function, output_fn which will be called with the Logger.output_log method\n\nsource\n\nLogger.output_log\n\n Logger.output_log ()\n\ncalls the user defined output function\n\nSample implementation with a custom write_logs method\n\nimport pandas as pd\n\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_error():\n    try:\n        if 1 == 1:\n            raise Exception(\"random error\")\n\n    except Exception as e:\n        logger.log_error(e)\n\n\ndef double_test():\n    test_error()\n\n\n# record first error\ntest_error()\n\n# records second error nested inside double_test()\ndouble_test()\n\nlogger.output_log()\n\nprinting logs\n\n\n\n\n\n\n  \n    \n      \n      date_time\n      application\n      log_type\n      log_message\n      breadcrumb\n      domo_instance\n      entity_id\n      function_name\n      file_name\n      function_trail\n    \n  \n  \n    \n      0\n      2023-01-12 01:50:47.156290\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-f54bafc5c909>\n      <module> -> test_error\n    \n    \n      1\n      2023-01-12 01:50:47.156464\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-f54bafc5c909>\n      <module> -> double_test -> test_error"
  },
  {
    "objectID": "transport.html",
    "href": "transport.html",
    "title": "Transport",
    "section": "",
    "text": "This code base supports two API request libraries, requests.request (synchronous) and aiohttp.ClientRequest (asynchronous) this can be extended as new libraries emerge with different performance characteristics.\n\n# if users pass auth_header to RequestTransport will be added to all auth requests\n\nrt = RequestTransport(auth_header={'x-domo-authentication': '123'})\nheaders = rt._headers_default_receive_json()\n\n# validate headers include authentication header\ntest_eq(headers.keys(), ['Accept', 'x-domo-authentication'])\n\n# validate timeout defaults to 10 seconds\ntest_eq(rt.request_timeout, 10)\n\n\n\nThe TransportSync class is a simple wrapper for requests.request\n\nsource\n\n\n\n TransportSync (auth_header:Optional[dict]=None, request_timeout:int=10)\n\nThe RequestTransport abstract base class adds consistency to the transport methods with consistent methods for generating headers, as well as generating requests from APIs.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nauth_header\ntyping.Optional[dict]\nNone\nfor API Authentication\n\n\nrequest_timeout\nint\n10\nfor default timeout to prevent infinite loops\n\n\n\n\n\n\nts = TransportSync(auth_header={'x-domo-authentication': '123'})\n\ntest_eq(isinstance(ts, TransportSync), True)\n\nget_res = ts.get(\n    url='http://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita')\n\n# test for a 200 status\ntest_eq(get_res.status, 200)\n\n# validate that the response object includes the sent headers\ntest_eq(get_res.auth_header.keys(), ['x-domo-authentication'])\n\n\n\n\n\n\nThe TransportAsync class is a wrapper for aiohttpâ€™s ClientSession and ClientResponse implementations. Notice the use of async/await in the code samples\n\nsource\n\n\n\n TransportAsync (auth_header:Optional[dict]=None, request_timeout:int=10,\n                 session:Optional[aiohttp.client.ClientSession]=None)\n\nwrapper for aiohttp.ClientSession and aiohttp.ClientResponse for handling asynchronous code execution. In the event of request_timeout, will default to synchronous code execution via requests.request library\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nauth_header\ntyping.Optional[dict]\nNone\nAPI Authentication header\n\n\nrequest_timeout\nint\n10\nrequest timeout to prevent infinite loops\n\n\nsession\ntyping.Optional[aiohttp.client.ClientSession]\nNone\n\n\n\n\n\n\n\ntas = TransportAsync(auth_header={'x-domo-authentication': '123'})\ntest_eq(isinstance(tas, TransportAsync), True)\n\nget_res = await tas.get(url='http://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita', request_timeout=10)\n\nget_res.response.get('drinks')[0].get('idDrink')\n\n# test for a 200 status\ntest_eq(get_res.status, 200)\n\n# validate that the response object includes the sent headers\ntest_eq(get_res.auth_header.keys(), ['x-domo-authentication'])\n\nget_res.response.get('drinks')[0].get('idDrink')\n\n'11007'\n\n\n\n\n\nTo LOOP over asynchronous code blocks, take advantage of asyncio.gather()\n\nNotice how the get_drink() function implements what would usually be contained within the FOR LOOP allowing us to implement a list comprehension. The asyncio.sleep() function highlights the fact that we are retrieving all the requests simultaneously.\nUse await asyncio.gather( * [list_of_asynchronous_functions]) forces the code to wait till all the APIs have returned a response before proceeding to the final step of printing the results.\nEach .get() request returns a ResponseGetData object. We can test iif(ResponseGetData.is_success) to validate having received a 200 response. The response contenent will always be in the .response attribute.\n\n\nasync def get_drink(drink_name: str):\n    url = f'http://www.thecocktaildb.com/api/json/v1/1/search.php?s={drink_name}'\n    print(f'getting - \"{url}\"')\n\n    await(asyncio.sleep(2))\n    return await tas.get(url=url)\n\ndrink_names = ['margarita', 'old fashioned',\n               'gin and tonic', 'screwdriver', 'vodka tonic']\n\ndrinks_requests = await asyncio.gather(\n    * [get_drink(drink_name) for drink_name in drink_names]\n)\n\nfor drink in drinks_requests:\n    [print(drink_match.get('idDrink'))\n     for drink_match in drink.response.get('drinks') if drink.is_success]\n\ngetting - \"http://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita\"\ngetting - \"http://www.thecocktaildb.com/api/json/v1/1/search.php?s=old fashioned\"\ngetting - \"http://www.thecocktaildb.com/api/json/v1/1/search.php?s=gin and tonic\"\ngetting - \"http://www.thecocktaildb.com/api/json/v1/1/search.php?s=screwdriver\"\ngetting - \"http://www.thecocktaildb.com/api/json/v1/1/search.php?s=vodka tonic\"\n11007\n11118\n17216\n16158\n12322\n178332\n11001\n11403\n12162\n12091\n178364\n\n\nBad pipe message: %s [b\"\\xe8\\xb8(\\xea%y7\\xe3R\\x93\\xdc\\x83%\\x15\\xce\\xf6\\xae\\x9d '\\x93R\\x99^\\xf6\\xe7\\xf9\\xb6\\x18\\x8d\\xcd\\xa0$\\xf0C\\x9e\\x81\\x0ca\\xc2\\x8c\\x0fD1;\\xd3!\\xb6\\x11\\xf7\\xd8\\x00\\x08\\x13\\x02\\x13\\x03\\x13\\x01\\x00\\xff\\x01\\x00\\x00\\x8f\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\n\\x00\\x0c\\x00\\n\\x00\\x1d\\x00\\x17\\x00\\x1e\\x00\\x19\\x00\\x18\\x00#\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\r\\x00\\x1e\\x00\\x1c\\x04\\x03\\x05\\x03\\x06\\x03\\x08\\x07\\x08\\x08\\x08\\t\\x08\\n\\x08\\x0b\\x08\\x04\\x08\\x05\\x08\\x06\\x04\\x01\\x05\\x01\\x06\\x01\\x00+\\x00\\x03\\x02\\x03\\x04\\x00-\\x00\\x02\\x01\\x01\\x003\\x00\", b'$\\x00\\x1d\\x00 7\\x9ce\\x0c\\x03r\\xb0\\xefDL\\xc1&\\x16\\x11\\xe4\\xaao\\x86-\\x8f\\x8d%mm\\x84.\\xcaAb\\x85\\x0bi']\nBad pipe message: %s [b\"\\xe3Z\\xb1\\xb8\\x16\\x01\\xd7\\x9b\\x19\\xaal\\xdf\\xd6\\xfc\\xe7\\xb3\\xa0\\x13\\x00\\x00|\\xc0,\\xc00\\x00\\xa3\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\xaf\\xc0\\xad\\xc0\\xa3\\xc0\\x9f\\xc0]\\xc0a\\xc0W\\xc0S\\xc0+\\xc0/\\x00\\xa2\\x00\\x9e\\xc0\\xae\\xc0\\xac\\xc0\\xa2\\xc0\\x9e\\xc0\\\\\\xc0`\\xc0V\\xc0R\\xc0$\\xc0(\\x00k\\x00j\\xc0#\\xc0'\\x00g\\x00@\\xc0\\n\\xc0\\x14\\x009\\x008\\xc0\\t\\xc0\\x13\\x003\\x002\\x00\\x9d\\xc0\\xa1\\xc0\\x9d\\xc0Q\\x00\\x9c\\xc0\\xa0\\xc0\\x9c\\xc0P\\x00=\\x00<\\x005\\x00/\\x00\\x9a\\x00\\x99\\xc0\\x07\\xc0\\x11\\x00\\x96\\x00\\x05\\x00\\xff\\x01\\x00\\x00j\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\n\\x00\\x0c\\x00\\n\\x00\\x1d\\x00\\x17\\x00\\x1e\\x00\\x19\\x00\\x18\\x00#\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\r\\x000\\x00.\\x04\\x03\\x05\\x03\\x06\\x03\\x08\\x07\\x08\\x08\\x08\\t\\x08\\n\\x08\\x0b\\x08\\x04\\x08\\x05\\x08\\x06\\x04\\x01\\x05\\x01\\x06\\x01\\x03\\x03\\x02\\x03\\x03\\x01\\x02\\x01\\x03\", b'\\x02']\nBad pipe message: %s [b'\\x05\\x02\\x06']\nBad pipe message: %s [b'|h\\t$\\xdfusgu\\x08^\\x8a\\xfe\\xbb\\x1c:\\x15\\x02\\x00\\x00\\xa6\\xc0,\\xc00\\x00\\xa3\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\xaf\\xc0\\xad\\xc0\\xa3\\xc0\\x9f\\xc0]\\xc0a\\xc0W\\xc0S\\xc0+\\xc0/\\x00\\xa2\\x00\\x9e\\xc0\\xae\\xc0\\xac\\xc0\\xa2\\xc0\\x9e\\xc0\\\\']\nBad pipe message: %s [b\"\\xc0V\\xc0R\\xc0$\\xc0(\\x00k\\x00j\\xc0s\\xc0w\\x00\\xc4\\x00\\xc3\\xc0#\\xc0'\\x00g\\x00@\\xc0r\\xc0v\\x00\\xbe\\x00\\xbd\\xc0\\n\\xc0\\x14\\x009\\x008\\x00\\x88\\x00\\x87\\xc0\\t\\xc0\\x13\\x003\\x002\\x00\\x9a\\x00\\x99\\x00E\\x00D\\xc0\\x07\\xc0\\x11\\xc0\\x08\\xc0\\x12\\x00\\x16\\x00\\x13\\x00\\x9d\\xc0\\xa1\\xc0\\x9d\\xc0Q\\x00\\x9c\\xc0\\xa0\\xc0\\x9c\\xc0P\\x00=\\x00\\xc0\\x00<\\x00\\xba\\x005\\x00\\x84\\x00/\\x00\\x96\\x00A\\x00\\x05\\x00\\n\\x00\\xff\\x01\\x00\\x00j\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\n\\x00\\x0c\\x00\\n\\x00\\x1d\\x00\\x17\\x00\\x1e\\x00\\x19\\x00\\x18\\x00#\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\r\\x000\\x00.\\x04\\x03\\x05\\x03\\x06\\x03\\x08\\x07\\x08\\x08\\x08\"]\nBad pipe message: %s [b'\\n\\x08\\x0b\\x08\\x04\\x08\\x05\\x08']\nBad pipe message: %s [b'\\x01\\x05\\x01\\x06\\x01']\nBad pipe message: %s [b'\\x02\\x03', b'\\x02\\x01', b'\\x02\\x02']\nBad pipe message: %s [b'\\x05\\x02\\x06']\nBad pipe message: %s [b'\\xf3\\x05T\\x1b/\\x8c\\x8a\\x14\\x05\\xfd>\\x9c\\xa6-\\x11P\\x91\\x02\\x00\\x00>\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\xc0\\x0f\\xc0\\x05\\x005\\xc0\\x13\\xc0\\t\\x00']\nBad pipe message: %s [b'2\\x001\\x000\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00\\x96\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\xff\\x02\\x01\\x00\\x00C\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00']\nBad pipe message: %s [b\"'\\x12\\xab\\xf5\\x13\\xa6\\xb6\\xe4\\x03\\x15\\x89\\\\\\xa4_tsv\\xe7\\x00\\x00\\xa2\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00:\\x00\\x89\\xc0\\x0f\\xc0\\x05\\x005\\x00\\x84\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x004\\x00\\x9b\\x00F\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x96\\x00A\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\xc0\\x12\\xc0\\x08\\x00\\x16\\x00\\x13\\x00\\x10\\x00\\r\\xc0\\x17\\x00\\x1b\\xc0\\r\\xc0\\x03\\x00\\n\\x00\\x15\\x00\\x12\\x00\\x0f\\x00\\x0c\\x00\\x1a\\x00\\t\\x00\\x14\\x00\\x11\\x00\\x19\\x00\\x08\\x00\\x06\"]\nBad pipe message: %s [b\"\\xae\\x07i\\x8e\\xea\\t\\x8d\\xaa\\x00y\\xf4\\xae\\xe9J\\x90'\\x80\\xc6\\x00\\x00>\\xc0\\x14\\xc0\\n\\x009\\x008\"]\nBad pipe message: %s [b'\\x7f=\\xd4.\\xeb\\x97\\xd8\\xca\\xfamH\\x89\\x1b\\x07@V\\xde!\\x00\\x00\\xa2\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00:\\x00\\x89\\xc0\\x0f\\xc0\\x05\\x005\\x00\\x84\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x004\\x00\\x9b\\x00F\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x96\\x00A\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\xc0\\x12\\xc0\\x08\\x00\\x16\\x00\\x13\\x00\\x10\\x00\\r\\xc0\\x17\\x00\\x1b\\xc0\\r\\xc0\\x03\\x00\\n\\x00\\x15\\x00\\x12\\x00\\x0f\\x00\\x0c\\x00\\x1a']\nBad pipe message: %s [b\"\\x95*\\xa5\\x1d\\x00\\xff\\xa1\\xd3n\\xd4BwT\\x12\\xe1;\\x97\\xc1\\x00\\x00\\x86\\xc00\\xc0,\\xc0(\\xc0$\\xc0\\x14\\xc0\\n\\x00\\xa5\\x00\\xa3\\x00\\xa1\\x00\\x9f\\x00k\\x00j\\x00i\\x00h\\x009\\x008\\x007\\x006\\xc02\\xc0.\\xc0*\\xc0&\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00=\\x005\\xc0/\\xc0+\\xc0'\\xc0#\\xc0\\x13\\xc0\\t\\x00\\xa4\\x00\\xa2\\x00\\xa0\\x00\\x9e\\x00g\\x00@\\x00?\\x00>\\x003\\x002\\x001\\x000\\xc01\\xc0-\\xc0\", b'%\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00<\\x00/\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00\\x96\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\xff\\x02\\x01\\x00']\nBad pipe message: %s [b\"s\\xda\\x15\\xa2\\x04\\x95\\n\\xc3\\xfb\\xf8YY)\\xb0e\\x02\\x16\\x84\\x00\\x00\\xf4\\xc00\\xc0,\\xc0(\\xc0$\\xc0\\x14\\xc0\\n\\x00\\xa5\\x00\\xa3\\x00\\xa1\\x00\\x9f\\x00k\\x00j\\x00i\\x00h\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00\\xa7\\x00m\\x00:\\x00\\x89\\xc02\\xc0.\\xc0*\\xc0&\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00=\\x005\\x00\\x84\\xc0/\\xc0+\\xc0'\\xc0#\\xc0\\x13\\xc0\\t\\x00\\xa4\\x00\\xa2\\x00\\xa0\\x00\\x9e\\x00\", b'@\\x00?\\x00>\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x00\\xa6\\x00l\\x004\\x00\\x9b\\x00F\\xc01\\xc0-\\xc0)\\xc0%\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00<\\x00/\\x00\\x96\\x00A\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\xc0\\x12\\xc0\\x08\\x00\\x16\\x00\\x13\\x00\\x10\\x00\\r\\xc0\\x17\\x00\\x1b\\xc0\\r\\xc0\\x03\\x00']\nBad pipe message: %s [b'\\x15\\x00\\x12\\x00\\x0f\\x00\\x0c\\x00\\x1a']"
  }
]